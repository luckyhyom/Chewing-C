#include <stdio.h>

/*
    배열은 첫번째 요소의 주소값을 가지고 있는 포인터라고 생각해도 좋다.
    arr[1]; // 배열의 메모리 시작 주소에서 한칸 이동해줘 -> *(&arr[0] + 1)

    1. 배열의 변수명은 sizeof 연산자나 주소값 연산자(&)와 사용될 때를 제외하면, 배열의 첫번째 원소를 가리키는 포인터로 암묵적 변환이 이뤄진다.
    
    2. 그렇다면 배열의 변수명에 주소값 연산자를 사용하면 어떻게 될까?
        int arr[3]; 일때 
        &arr은, [int 자료형 3개만큼의 크기를 할당한 데이터의 주소]를 반환한다.
        따라서, &arr을 저장할 포인터는 [int 자료형 3개만큼의 크기를 할당한 데이터의 주소]를 나타내는 자료형이어야한다.
        int (*parr)[3] = &arr;
    
    why?
    애초에 포인터에 자료형을 사용하는 이유는 시작 주소로 부터 얼만큼의 크기를 읽을지 정보를 주기 위해서다.
    따라서! 배열의 포인터를 선언할거면, 얼만큼을 읽어야 하는지 정보를 주어야한다. (자료형과 원소 개수)
        printf("%d", *parr); => 시작 주소로 부터 얼만큼의 메모리를 읽을것인가.
*/
int main() {
    int arr[3] = {1, 2, 3};
    /* arr은 포인터다! */
    int* parr = arr; // arr = &arr[0] | arr[1] = &arr[0] + 1

    /*
        배열[n] = *(배열의 시작 주소 + n칸)
        n칸 = 자료형 * n

        검증
        printf("arr = %p \n", arr);
        printf("arr = %p \n", arr + 1);
     */
    printf("arr[1] = %d \n", arr[1]); // 주소에서 한칸 이동해라!
    printf("*(arr + 1) = %d \n", *(arr + 1)); // 주소에서 한칸 이동해라!
    printf("(&arr[0])[1] = %d \n", (&arr[0])[1]); // 주소에서 한칸 이동해라!
    printf("parr[1] = %d \n", parr[1]); // 주소에서 한칸 이동해라!
    return 0;
}