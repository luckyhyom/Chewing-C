#include <stdio.h>

int main() {
    /*
        arr은 첫번째 원소를 가리키는 포인터로 암묵적 변환된다.
        arr = &arr[0] = {1,2,3}에 대한 주소
        따라서, &arr[0]을 저장하는 포인터는 int형

        int arr[3] = {1,2,3};
        에서의 arr은..
        arr = &arr[0] = 1 = int*
        &arr = int (*)[3] = int 자료형 3개 크기를 가진 데이터를 가리키는 포인터
    */
    int arr[2][3] = {{1,2,3},{4,5,6}};

    int (*parr)[3];
    parr = arr;
    printf("%d", parr[1][1]); // parr = arr 이니까.. (*parr) 하면 안됨
    return 0;
}

/*
    주절주절..

    arr은 첫번째 원소를 가리키는 포인터로 암묵적 변환된다.
    arr = &arr[0] = {1,2,3}에 대한 주소
    따라서, &arr[0]을 저장하는 포인터는 int형

    int arr[3] = {1,2,3};
    에서의 arr은..
    arr = &arr[0] = 1 = int*
    &arr = int (*)[3] = int 자료형 3개 크기를 가진 데이터를 가리키는 포인터

    아래 둘은.. 다르다. 포인터는 포인터인데, 시작 주소에서 부터 읽어들일 크기를 알려줘야한다. 포인터는 그냥 주소일 뿐이다.
    int *parr = arr;
    int *parr = &arr;
    Q. 그럼 그냥 더블포인터로 잘못 정의를 하더라도 한번만 값을 꺼내면 상관없어지나?

    int arr[2][3] = {{1,2,3},{4,5,6}};
    에서의 arr은..
    arr = &arr[0] = {1,2,3} = int (*)[3] = int 자료형 3개 크기를 가진 데이터를 가리키는 포인터
    &arr = int (*)[2][3] = 읽어들일 크기 : 4byte * 2 * 3
*/